import {execFile} from "node:child_process";
import * as Uf from "./UtilFs.js";
import Um from "./UtilMisc.js";
import fs from "fs";
import {hash} from "hasha";
import {getCleanJson} from "./UtilClean.js";

export class BrewTimestamper {
	static _LOG_TAG = `TIMESTAMPS`;

	static _UPDATE_TYPES = {
		NONE: 0,
		HASH: 1,
		TIMESTAMP: 2,
	};

	static async _pUpdateDir (dir) {
		const promises = Uf.listJsonFiles(dir)
			.map(async file => {
				const fileData = Uf.readJsonSync(file, {isIncludeRaw: true});

				if (!fileData.json._meta) {
					throw new Error(`File "${file}" did not have metadata!`);
				}

				let updateType = this._UPDATE_TYPES.NONE;

				// We hash the file without `dateAdded`, `dateLastModified`, and `_dateLastModifiedHash` to ensure the hash
				//   is stable when changing date values.
				const toHashObj = {...fileData.json};
				toHashObj._meta = {...toHashObj._meta, dateAdded: undefined, dateLastModified: undefined, _dateLastModifiedHash: undefined};
				const expectedHash = await this._pGetHash(toHashObj);

				if (!fileData.json._meta._dateLastModifiedHash) {
					updateType = this._UPDATE_TYPES.HASH;
					fileData.json._meta._dateLastModifiedHash = expectedHash;
				} else if (expectedHash !== fileData.json._meta._dateLastModifiedHash) {
					// Grab the last commit timestamp from the log.
					// This is often a "junk" commit generated by cleaning (or indeed, timestamping) the file, but this is
					//   good enough.
					const dateLastModified = await new Promise((resolve, reject) => {
						execFile(
							"git",
							["log", "-1", `--format="%ad"`, file],
							{
								windowsHide: true,
							},
							(err, stdout, stderr) => {
								if (err) return reject(err);
								resolve(Math.round(new Date(stdout.trim()).getTime() / 1000));
							},
						);
					});

					if (fileData.json._meta.dateLastModified < dateLastModified) {
						updateType = this._UPDATE_TYPES.TIMESTAMP;
						fileData.json._meta.dateLastModified = dateLastModified;
						fileData.json._meta._dateLastModifiedHash = expectedHash;
					}
				}

				if (updateType === this._UPDATE_TYPES.NONE) return;

				const strContents = getCleanJson(fileData.json);

				await new Promise((resolve, reject) => {
					fs.writeFile(
						file,
						strContents,
						(err) => {
							if (err) return reject(err);
							resolve();
						},
					);
				});

				Um.info(
					this._LOG_TAG,
					updateType === this._UPDATE_TYPES.HASH
						? `\t- Updated "_dateLastModifiedHash" for "${file}"...`
						: `\t- Updated "dateLastModified" for "${file}"...`,
				);
			});

		await Promise.all(promises);
	}

	static async _pGetHash (obj) {
		return (await hash(JSON.stringify(obj))).slice(0, 10);
	}

	static async pRun () {
		await Uf.pRunOnDirs(
			async (dir) => {
				Um.info(this._LOG_TAG, `Updating dateLastModified timestamps in dir "${dir}"...`);
				await this._pUpdateDir(dir);
			},
			{
				isSerial: true,
			},
		);
		Um.info(this._LOG_TAG, "Done!");
	}
}
